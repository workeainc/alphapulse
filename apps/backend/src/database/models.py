#!/usr/bin/env python3
"""
Consolidated Database Models for AlphaPulse
Single source of truth for all database schemas and ORM models
Enhanced with Market Regime Detection and comprehensive documentation
"""

from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, Text, ForeignKey, JSON, Index, UniqueConstraint
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
from datetime import datetime
from typing import Optional, Dict, Any
import os

# Import settings from unified config
try:
    from ..src.core.config import settings
except ImportError:
    # Fallback to environment variables
    try:
        from dotenv import load_dotenv
        # Try to load .env file, but don't fail if it doesn't exist or has encoding issues
        try:
            load_dotenv()
        except Exception:
            pass  # Ignore dotenv loading errors
    except ImportError:
        pass
    
    class FallbackSettings:
        DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://alpha_emon:Emon_%4017711@localhost:55433/alphapulse")
        DEBUG = os.getenv("DEBUG", "False").lower() == "true"
    settings = FallbackSettings()

# Create database engine
engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


class Signal(Base):
    """
    Signal model for trading signals with comprehensive metadata
    
    Stores all trading signals generated by the AlphaPulse system with
    complete metadata including indicators, validation metrics, and market regime.
    Supports JSONB fields for flexible indicator and metric storage.
    
    Stores signals from ALL sources (pattern detection, ML models, ensemble, etc.)
    differentiated by the 'source' field.
    """
    
    __tablename__ = "signals"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), unique=True, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timeframe = Column(String(10), nullable=False, index=True)
    direction = Column(String(10), nullable=False)  # 'long' or 'short'
    confidence = Column(Float, nullable=False)
    entry_price = Column(Float, nullable=False)
    source = Column(String(50), nullable=True, index=True, comment='Signal source: pattern, ml_ensemble, hybrid, manual')
    source_model = Column(String(100), nullable=True, comment='Specific model name if ML-generated')
    tp1 = Column(Float, nullable=True)
    tp2 = Column(Float, nullable=True)
    tp3 = Column(Float, nullable=True)
    tp4 = Column(Float, nullable=True)
    stop_loss = Column(Float, nullable=True)
    risk_reward_ratio = Column(Float, nullable=True)
    pattern_type = Column(String(50), nullable=True)
    volume_confirmation = Column(Boolean, default=False)
    trend_alignment = Column(Boolean, default=False)
    market_regime = Column(String(50), nullable=True)  # Market regime at signal time
    indicators = Column(JSON, nullable=True)  # Store all technical indicators
    validation_metrics = Column(JSON, nullable=True)  # Store validation metrics
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    outcome = Column(String(20), default='pending')  # 'pending', 'success', 'failure', 'partial'
    
    # Relationships
    logs = relationship("Log", back_populates="signal")
    feedback = relationship("Feedback", back_populates="signal")
    
    def __repr__(self):
        return f"<Signal(signal_id='{self.signal_id}', symbol='{self.symbol}', direction='{self.direction}')>"


class Log(Base):
    """
    Log model for system logging and debugging
    
    Stores detailed logs for each signal including pattern detection,
    confidence scoring, volume context, and trend analysis.
    """
    
    __tablename__ = "logs"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), ForeignKey("signals.signal_id"), nullable=False, index=True)
    pattern_type = Column(String(50), nullable=True)
    confidence_score = Column(Float, nullable=True)
    volume_context = Column(JSON, nullable=True)  # Volume analysis context
    trend_context = Column(JSON, nullable=True)  # Trend analysis context
    outcome = Column(String(20), nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    # Relationships
    signal = relationship("Signal", back_populates="logs")
    
    def __repr__(self):
        return f"<Log(signal_id='{self.signal_id}', pattern_type='{self.pattern_type}')>"


class Feedback(Base):
    """
    Feedback model for signal outcome tracking
    
    Stores feedback on signal outcomes including market results,
    notes, and performance metrics for continuous improvement.
    """
    
    __tablename__ = "feedback"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), ForeignKey("signals.signal_id"), nullable=False, index=True)
    market_outcome = Column(Float, nullable=True)  # Actual market outcome
    notes = Column(Text, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    signal = relationship("Signal", back_populates="feedback")
    
    def __repr__(self):
        return f"<Feedback(signal_id='{self.signal_id}', market_outcome={self.market_outcome})>"


class PerformanceMetrics(Base):
    """
    Performance metrics model for system monitoring
    
    Stores comprehensive performance metrics including latency,
    throughput, accuracy, and filter rates for system optimization.
    """
    
    __tablename__ = "performance_metrics"
    
    id = Column(Integer, primary_key=True, index=True)
    test_run_id = Column(String(100), nullable=False, index=True)
    latency_avg_ms = Column(Float, nullable=True)
    latency_max_ms = Column(Float, nullable=True)
    throughput_signals_sec = Column(Float, nullable=True)
    accuracy = Column(Float, nullable=True)
    filter_rate = Column(Float, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    def __repr__(self):
        return f"<PerformanceMetrics(test_run_id='{self.test_run_id}', accuracy={self.accuracy})>"


class MarketRegime(Base):
    """
    Market regime model for regime detection tracking
    
    Stores market regime classifications and transitions for
    analysis and backtesting of regime-based strategies.
    """
    
    __tablename__ = "market_regimes"
    
    id = Column(Integer, primary_key=True, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timeframe = Column(String(10), nullable=False, index=True)
    regime_type = Column(String(50), nullable=False)  # 'strong_trend_bull', 'ranging', etc.
    confidence = Column(Float, nullable=True)
    duration_candles = Column(Integer, nullable=True)
    metrics = Column(JSON, nullable=True)  # Regime classification metrics
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    def __repr__(self):
        return f"<MarketRegime(symbol='{self.symbol}', regime_type='{self.regime_type}')>"


class SignalRecommendation(Base):
    """
    Signal Recommendation model for trading recommendations
    
    ⚠️ IMPORTANT: This is for RECOMMENDATIONS only, NOT executed trades.
    
    Stores recommended trades for users to manually execute, including
    suggested entry/exit prices, stop-loss, take-profit, and position sizing.
    
    AlphaPulse is a Signal Analysis Engine - it does NOT execute trades.
    Users receive recommendations and manually execute on their own exchange.
    
    The 'hypothetical_pnl' fields track outcomes IF user followed the recommendation,
    used for ML model validation and improvement only.
    """
    
    __tablename__ = "signal_recommendations"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), ForeignKey("signals.signal_id"), nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    side = Column(String(10), nullable=False)  # 'long' or 'short'
    suggested_entry_price = Column(Float, nullable=False)
    suggested_exit_price = Column(Float, nullable=True)
    suggested_quantity = Column(Float, nullable=False)
    suggested_leverage = Column(Integer, default=1)
    hypothetical_pnl = Column(Float, nullable=True)  # For tracking if user followed recommendation
    hypothetical_pnl_percentage = Column(Float, nullable=True)
    
    # Strategy information
    strategy_name = Column(String(100), nullable=False)
    strategy_signals = Column(JSON, nullable=True)  # Store all signals that triggered this recommendation
    
    # Risk management recommendations
    suggested_stop_loss = Column(Float, nullable=True)
    suggested_take_profit = Column(Float, nullable=True)
    suggested_trailing_stop = Column(Float, nullable=True)
    
    # Market conditions (context for recommendation)
    market_regime = Column(String(50), nullable=True)  # "trending", "ranging", "volatile"
    sentiment_score = Column(Float, nullable=True)
    volatility = Column(Float, nullable=True)
    
    # Multi-timeframe analysis
    timeframe_signals = Column(JSON, nullable=True)  # Store signals from different timeframes
    
    # News impact
    news_impact = Column(String(100), nullable=True)
    
    # Status and timing
    status = Column(String(20), default='pending')  # 'pending', 'user_executed', 'expired', 'cancelled'
    recommendation_time = Column(DateTime, default=datetime.utcnow, index=True)
    expiry_time = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Additional metadata
    notes = Column(Text, nullable=True)
    tags = Column(JSON, nullable=True)
    
    def __repr__(self):
        return f"<SignalRecommendation(symbol='{self.symbol}', side='{self.side}', status='{self.status}')>"


# Backward compatibility alias (DEPRECATED)
import warnings
Trade = SignalRecommendation  # DEPRECATED: Use SignalRecommendation instead
warnings.warn(
    "Trade model has been renamed to SignalRecommendation. Please update your imports.",
    DeprecationWarning,
    stacklevel=2
)


class Strategy(Base):
    """
    Strategy model for strategy configurations
    
    Stores strategy configurations and parameters for different
    trading strategies used in the AlphaPulse system.
    """
    
    __tablename__ = "strategies"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), unique=True, nullable=False, index=True)
    description = Column(Text, nullable=True)
    strategy_type = Column(String(50), nullable=False)  # 'trend_following', 'mean_reversion', etc.
    
    # Strategy parameters
    parameters = Column(JSON, nullable=True)  # Strategy-specific parameters
    risk_parameters = Column(JSON, nullable=True)  # Risk management parameters
    
    # Performance tracking (based on hypothetical outcomes)
    total_signals = Column(Integer, default=0, comment='Total signals generated by this strategy')
    successful_signals = Column(Integer, default=0, comment='Signals with positive hypothetical outcomes')
    accuracy = Column(Float, default=0.0, comment='Percentage of successful signals (hypothetical)')
    avg_hypothetical_return = Column(Float, default=0.0, comment='Average hypothetical return if all signals were followed')
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<Strategy(name='{self.name}', type='{self.strategy_type}')>"


class Indicator(Base):
    """
    Indicator model for technical indicator storage
    
    PURPOSE: Pre-computed indicator cache for performance optimization.
    Stores calculated technical indicators separately from signals for:
    - Fast historical lookups without recomputing
    - Cross-timeframe indicator analysis
    - Backtesting and strategy optimization
    
    Note: signals.indicators JSON field stores indicators AT signal generation time.
    This table stores ALL indicator values for historical analysis.
    """
    
    __tablename__ = "indicators"
    
    id = Column(Integer, primary_key=True, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timeframe = Column(String(10), nullable=False, index=True)
    indicator_name = Column(String(50), nullable=False, index=True)
    value = Column(Float, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    # Additional context
    parameters = Column(JSON, nullable=True)  # Indicator parameters
    context = Column(JSON, nullable=True)  # Additional context data
    
    def __repr__(self):
        return f"<Indicator(symbol='{self.symbol}', name='{self.indicator_name}', value={self.value})>"


class Model(Base):
    """
    Model model for ML model storage
    
    Stores information about trained machine learning models
    including metadata, performance metrics, and versioning.
    """
    
    __tablename__ = "models"
    
    id = Column(Integer, primary_key=True, index=True)
    model_name = Column(String(100), nullable=False, index=True)
    model_type = Column(String(50), nullable=False)  # 'random_forest', 'neural_network', etc.
    version = Column(String(20), nullable=False)
    
    # Model metadata
    parameters = Column(JSON, nullable=True)  # Model hyperparameters
    features = Column(JSON, nullable=True)  # Feature list
    performance_metrics = Column(JSON, nullable=True)  # Training performance
    
    # File storage
    model_path = Column(String(500), nullable=True)  # Path to model file
    model_size_mb = Column(Float, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<Model(name='{self.model_name}', type='{self.model_type}', version='{self.version}')>"


class DataVersion(Base):
    """
    Data version model for data versioning
    
    PURPOSE: Tracks different versions of training data and feature sets
    for ML model reproducibility and audit trails.
    
    Use Case: When experimenting with different feature sets or data sources,
    this table maintains version history for reproducible ML experiments.
    
    ⚠️ Optional: Can be removed if not doing ML research/experimentation.
    """
    
    __tablename__ = "data_versions"
    
    id = Column(Integer, primary_key=True, index=True)
    version_name = Column(String(100), unique=True, nullable=False, index=True)
    description = Column(Text, nullable=True)
    
    # Data metadata
    data_source = Column(String(100), nullable=True)
    data_range_start = Column(DateTime, nullable=True)
    data_range_end = Column(DateTime, nullable=True)
    total_records = Column(Integer, nullable=True)
    
    # Feature information
    feature_count = Column(Integer, nullable=True)
    feature_list = Column(JSON, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f"<DataVersion(name='{self.version_name}', records={self.total_records})>"


# Create indexes for performance optimization
Index('idx_signals_symbol_timeframe', Signal.symbol, Signal.timeframe)
Index('idx_signals_timestamp', Signal.timestamp)
Index('idx_signals_source', Signal.source)
Index('idx_logs_timestamp', Log.timestamp)
Index('idx_feedback_signal_id', Feedback.signal_id)
Index('idx_performance_test_run', PerformanceMetrics.test_run_id)
Index('idx_market_regimes_symbol_timeframe', MarketRegime.symbol, MarketRegime.timeframe)
Index('idx_signal_recommendations_symbol_status', SignalRecommendation.symbol, SignalRecommendation.status)
Index('idx_indicators_symbol_name', Indicator.symbol, Indicator.indicator_name)
Index('idx_models_name_type', Model.model_name, Model.model_type)
Index('idx_user_settings_user_id', UserSettings.user_id)
Index('idx_alert_history_signal_user', AlertHistory.signal_id, AlertHistory.user_id)
Index('idx_alert_history_sent_at', AlertHistory.sent_at)

# Create unique constraints
UniqueConstraint('signal_id', name='uq_signal_id')
UniqueConstraint('name', name='uq_strategy_name')
UniqueConstraint('model_name', 'version', name='uq_model_name_version')
UniqueConstraint('version_name', name='uq_data_version_name')


class MLPrediction(Base):
    """
    ML Prediction model for storing machine learning model predictions
    
    Stores predictions from various ML models (ensemble, student, ONNX) with
    performance metrics and feature information for analysis and optimization.
    """
    
    __tablename__ = "ml_predictions"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    model_name = Column(String(100), nullable=False, index=True)
    model_type = Column(String(50), nullable=False)  # 'ensemble', 'student', 'onnx'
    prediction = Column(Float, nullable=False)
    confidence = Column(Float, nullable=True)
    features_used = Column(JSON, nullable=True)
    inference_latency_ms = Column(Float, nullable=True)
    cache_hit = Column(Boolean, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationships
    signals = relationship("MLSignal", back_populates="prediction")
    
    def __repr__(self):
        return f"<MLPrediction(symbol='{self.symbol}', model='{self.model_name}', prediction={self.prediction})>"


class MLSignal(Base):
    """
    ML Signal model for storing trading signals generated by ML models
    
    ⚠️ NOTE: Consider consolidating with main 'signals' table.
    
    This table stores ML-specific signal metadata. However, the main 'signals' table
    now has 'source' and 'source_model' fields that can handle ML signals.
    
    RECOMMENDATION: Use main 'signals' table with source='ml_ensemble' instead of this table
    to reduce duplication. This table can be phased out.
    
    Stores trading signals with confidence scores, risk metrics, and
    market conditions for comprehensive signal analysis and backtesting.
    """
    
    __tablename__ = "ml_signals"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    signal_type = Column(String(20), nullable=False, index=True)  # 'buy', 'sell', 'hold'
    signal_strength = Column(Float, nullable=False)
    model_name = Column(String(100), nullable=False, index=True)
    prediction_id = Column(Integer, ForeignKey("ml_predictions.id"), nullable=True)
    confidence = Column(Float, nullable=True)
    risk_score = Column(Float, nullable=True)
    market_conditions = Column(JSON, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationships
    prediction = relationship("MLPrediction", back_populates="signals")
    
    def __repr__(self):
        return f"<MLSignal(symbol='{self.symbol}', type='{self.signal_type}', strength={self.signal_strength})>"


class MLModelPerformance(Base):
    """
    ML Model Performance model for tracking model performance metrics
    
    Stores performance metrics for ML models including accuracy, latency,
    and other key performance indicators for model optimization and selection.
    """
    
    __tablename__ = "ml_model_performance"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    model_name = Column(String(100), nullable=False, index=True)
    model_type = Column(String(50), nullable=False, index=True)
    metric_name = Column(String(50), nullable=False, index=True)  # 'accuracy', 'latency_p50', 'latency_p99', etc.
    metric_value = Column(Float, nullable=False)
    sample_count = Column(Integer, nullable=True)
    time_window_minutes = Column(Integer, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    def __repr__(self):
        return f"<MLModelPerformance(model='{self.model_name}', metric='{self.metric_name}', value={self.metric_value})>"


class UserSettings(Base):
    """
    User Settings model for user preferences and notification configuration
    
    Since AlphaPulse is a recommendation engine (not execution platform),
    users need to configure how they want to receive signal notifications
    and what types of signals they're interested in.
    """
    
    __tablename__ = "user_settings"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(String(100), unique=True, nullable=False, index=True)
    email = Column(String(200), nullable=True)
    
    # Notification preferences
    notification_preferences = Column(JSON, nullable=True, comment='Email, Telegram, Discord, Webhook URLs')
    
    # Signal filtering preferences
    preferred_symbols = Column(JSON, nullable=True, comment='List of symbols user wants to track')
    min_confidence_threshold = Column(Float, default=0.75, comment='Minimum confidence for alerts')
    preferred_timeframes = Column(JSON, nullable=True, comment='Preferred timeframes like 1h, 4h, 1d')
    risk_tolerance = Column(String(20), default='medium', comment='low, medium, high')
    
    # Alert settings
    alert_high_confidence_only = Column(Boolean, default=True, comment='Only alert for high confidence signals')
    alert_frequency = Column(String(20), default='immediate', comment='immediate, hourly, daily')
    quiet_hours_start = Column(Integer, nullable=True, comment='Hour to start quiet period (0-23)')
    quiet_hours_end = Column(Integer, nullable=True, comment='Hour to end quiet period (0-23)')
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<UserSettings(user_id='{self.user_id}', risk_tolerance='{self.risk_tolerance}')>"


class AlertHistory(Base):
    """
    Alert History model for tracking sent notifications
    
    Tracks all alerts/notifications sent to users for signal recommendations.
    Helps prevent duplicate alerts and provides audit trail.
    """
    
    __tablename__ = "alert_history"
    
    id = Column(Integer, primary_key=True, index=True)
    alert_id = Column(String(100), unique=True, nullable=False, index=True)
    signal_id = Column(String(100), ForeignKey("signals.signal_id"), nullable=False, index=True)
    user_id = Column(String(100), nullable=True, index=True)
    
    # Alert details
    alert_type = Column(String(50), nullable=False, comment='new_signal, price_target, stop_loss, etc.')
    delivery_method = Column(String(50), nullable=False, comment='email, telegram, discord, webhook, in_app')
    priority = Column(String(20), nullable=True, comment='low, medium, high, critical')
    
    # Delivery status
    sent_at = Column(DateTime, nullable=False, index=True)
    delivered = Column(Boolean, default=False)
    delivery_error = Column(Text, nullable=True)
    read_at = Column(DateTime, nullable=True)
    
    # Alert content
    message = Column(Text, nullable=True)
    metadata = Column(JSON, nullable=True, comment='Additional alert metadata')
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f"<AlertHistory(alert_id='{self.alert_id}', signal_id='{self.signal_id}', delivered={self.delivered})>"


def create_tables():
    """Create all database tables"""
    Base.metadata.create_all(bind=engine)


def get_session():
    """Get database session"""
    return SessionLocal()


# Example usage and documentation
def example_usage():
    """
    Example usage of the database models
    
    This function demonstrates how to use the database models
    for common operations like creating signals, storing logs,
    and tracking performance metrics.
    """
    
    # Create a new signal
    signal = Signal(
        signal_id="BTC_USDT_15m_rsi_div_20250815_143022",
        symbol="BTC/USDT",
        timeframe="15m",
        direction="long",
        confidence=0.85,
        entry_price=45000.0,
        source="pattern",  # NEW: Specify signal source
        source_model=None,  # NULL for non-ML signals
        tp1=45900.0,
        tp2=46800.0,
        tp3=47700.0,
        tp4=48600.0,
        stop_loss=44100.0,
        risk_reward_ratio=2.5,
        pattern_type="rsi_divergence",
        volume_confirmation=True,
        trend_alignment=True,
        market_regime="strong_trend_bull",
        indicators={
            "rsi": 35.2,
            "macd": 0.85,
            "bollinger_position": 0.15,
            "volume_ratio": 1.8,
            "atr": 1200.0
        },
        validation_metrics={
            "volume_ratio": 1.8,
            "trend_strength": 0.75,
            "volatility": 1200.0,
            "momentum": 35.2,
            "breakout_strength": 0.85
        }
    )
    
    # Create a log entry
    log = Log(
        signal_id=signal.signal_id,
        pattern_type="rsi_divergence",
        confidence_score=0.85,
        volume_context={
            "volume_sma": 1500000,
            "current_volume": 2700000,
            "volume_ratio": 1.8
        },
        trend_context={
            "ema_20": 44800,
            "ema_50": 44500,
            "trend_direction": "bullish",
            "trend_strength": 0.75
        }
    )
    
    # Create performance metrics
    perf_metrics = PerformanceMetrics(
        test_run_id="test_run_20250815_143022",
        latency_avg_ms=45.2,
        latency_max_ms=78.5,
        throughput_signals_sec=22.1,
        accuracy=0.82,
        filter_rate=0.65
    )
    
    return signal, log, perf_metrics


if __name__ == "__main__":
    # Create tables when run directly
    create_tables()
    print("Database tables created successfully!")
    
    # Show example usage
    signal, log, perf_metrics = example_usage()
    print(f"Example signal: {signal}")
    print(f"Example log: {log}")
    print(f"Example performance metrics: {perf_metrics}")
