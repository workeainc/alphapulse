#!/usr/bin/env python3
"""
Consolidated Database Models for AlphaPulse
Single source of truth for all database schemas and ORM models
Enhanced with Market Regime Detection and comprehensive documentation
"""

from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, Text, ForeignKey, JSON, Index, UniqueConstraint
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
from datetime import datetime
from typing import Optional, Dict, Any
import os

# Import settings from unified config
try:
    from ..core.config import settings
except ImportError:
    # Fallback to environment variables
    try:
        from dotenv import load_dotenv
        # Try to load .env file, but don't fail if it doesn't exist or has encoding issues
        try:
            load_dotenv()
        except Exception:
            pass  # Ignore dotenv loading errors
    except ImportError:
        pass
    
    class FallbackSettings:
        DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://alpha_emon:Emon_%4017711@localhost:5432/alphapulse")
        DEBUG = os.getenv("DEBUG", "False").lower() == "true"
    settings = FallbackSettings()

# Create database engine
engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


class Signal(Base):
    """
    Signal model for trading signals with comprehensive metadata
    
    Stores all trading signals generated by the AlphaPulse system with
    complete metadata including indicators, validation metrics, and market regime.
    Supports JSONB fields for flexible indicator and metric storage.
    """
    
    __tablename__ = "signals"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), unique=True, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timeframe = Column(String(10), nullable=False, index=True)
    direction = Column(String(10), nullable=False)  # 'long' or 'short'
    confidence = Column(Float, nullable=False)
    entry_price = Column(Float, nullable=False)
    tp1 = Column(Float, nullable=True)
    tp2 = Column(Float, nullable=True)
    tp3 = Column(Float, nullable=True)
    tp4 = Column(Float, nullable=True)
    stop_loss = Column(Float, nullable=True)
    risk_reward_ratio = Column(Float, nullable=True)
    pattern_type = Column(String(50), nullable=True)
    volume_confirmation = Column(Boolean, default=False)
    trend_alignment = Column(Boolean, default=False)
    market_regime = Column(String(50), nullable=True)  # Market regime at signal time
    indicators = Column(JSON, nullable=True)  # Store all technical indicators
    validation_metrics = Column(JSON, nullable=True)  # Store validation metrics
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    outcome = Column(String(20), default='pending')  # 'pending', 'success', 'failure', 'partial'
    
    # Relationships
    logs = relationship("Log", back_populates="signal")
    feedback = relationship("Feedback", back_populates="signal")
    
    def __repr__(self):
        return f"<Signal(signal_id='{self.signal_id}', symbol='{self.symbol}', direction='{self.direction}')>"


class Log(Base):
    """
    Log model for system logging and debugging
    
    Stores detailed logs for each signal including pattern detection,
    confidence scoring, volume context, and trend analysis.
    """
    
    __tablename__ = "logs"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), ForeignKey("signals.signal_id"), nullable=False, index=True)
    pattern_type = Column(String(50), nullable=True)
    confidence_score = Column(Float, nullable=True)
    volume_context = Column(JSON, nullable=True)  # Volume analysis context
    trend_context = Column(JSON, nullable=True)  # Trend analysis context
    outcome = Column(String(20), nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    # Relationships
    signal = relationship("Signal", back_populates="logs")
    
    def __repr__(self):
        return f"<Log(signal_id='{self.signal_id}', pattern_type='{self.pattern_type}')>"


class Feedback(Base):
    """
    Feedback model for signal outcome tracking
    
    Stores feedback on signal outcomes including market results,
    notes, and performance metrics for continuous improvement.
    """
    
    __tablename__ = "feedback"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), ForeignKey("signals.signal_id"), nullable=False, index=True)
    market_outcome = Column(Float, nullable=True)  # Actual market outcome
    notes = Column(Text, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    signal = relationship("Signal", back_populates="feedback")
    
    def __repr__(self):
        return f"<Feedback(signal_id='{self.signal_id}', market_outcome={self.market_outcome})>"


class PerformanceMetrics(Base):
    """
    Performance metrics model for system monitoring
    
    Stores comprehensive performance metrics including latency,
    throughput, accuracy, and filter rates for system optimization.
    """
    
    __tablename__ = "performance_metrics"
    
    id = Column(Integer, primary_key=True, index=True)
    test_run_id = Column(String(100), nullable=False, index=True)
    latency_avg_ms = Column(Float, nullable=True)
    latency_max_ms = Column(Float, nullable=True)
    throughput_signals_sec = Column(Float, nullable=True)
    accuracy = Column(Float, nullable=True)
    filter_rate = Column(Float, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    def __repr__(self):
        return f"<PerformanceMetrics(test_run_id='{self.test_run_id}', accuracy={self.accuracy})>"


class MarketRegime(Base):
    """
    Market regime model for regime detection tracking
    
    Stores market regime classifications and transitions for
    analysis and backtesting of regime-based strategies.
    """
    
    __tablename__ = "market_regimes"
    
    id = Column(Integer, primary_key=True, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timeframe = Column(String(10), nullable=False, index=True)
    regime_type = Column(String(50), nullable=False)  # 'strong_trend_bull', 'ranging', etc.
    confidence = Column(Float, nullable=True)
    duration_candles = Column(Integer, nullable=True)
    metrics = Column(JSON, nullable=True)  # Regime classification metrics
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    def __repr__(self):
        return f"<MarketRegime(symbol='{self.symbol}', regime_type='{self.regime_type}')>"


class Trade(Base):
    """
    Trade model for executed trades
    
    Stores information about actual trades executed based on signals,
    including entry/exit prices, P&L, and risk management details.
    """
    
    __tablename__ = "trades"
    
    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(String(100), ForeignKey("signals.signal_id"), nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    side = Column(String(10), nullable=False)  # 'long' or 'short'
    entry_price = Column(Float, nullable=False)
    exit_price = Column(Float, nullable=True)
    quantity = Column(Float, nullable=False)
    leverage = Column(Integer, default=1)
    pnl = Column(Float, nullable=True)
    pnl_percentage = Column(Float, nullable=True)
    
    # Strategy information
    strategy_name = Column(String(100), nullable=False)
    strategy_signals = Column(JSON, nullable=True)  # Store all signals that triggered this trade
    
    # Risk management
    stop_loss = Column(Float, nullable=True)
    take_profit = Column(Float, nullable=True)
    trailing_stop = Column(Float, nullable=True)
    
    # Market conditions
    market_regime = Column(String(50), nullable=True)  # "trending", "ranging", "volatile"
    sentiment_score = Column(Float, nullable=True)
    volatility = Column(Float, nullable=True)
    
    # Multi-timeframe analysis
    timeframe_signals = Column(JSON, nullable=True)  # Store signals from different timeframes
    
    # News impact
    news_impact = Column(String(100), nullable=True)
    
    # Status and timing
    status = Column(String(20), default='open')  # 'open', 'closed', 'cancelled'
    entry_time = Column(DateTime, default=datetime.utcnow, index=True)
    exit_time = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Additional metadata
    notes = Column(Text, nullable=True)
    tags = Column(JSON, nullable=True)
    
    def __repr__(self):
        return f"<Trade(symbol='{self.symbol}', side='{self.side}', status='{self.status}')>"


class Strategy(Base):
    """
    Strategy model for strategy configurations
    
    Stores strategy configurations and parameters for different
    trading strategies used in the AlphaPulse system.
    """
    
    __tablename__ = "strategies"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), unique=True, nullable=False, index=True)
    description = Column(Text, nullable=True)
    strategy_type = Column(String(50), nullable=False)  # 'trend_following', 'mean_reversion', etc.
    
    # Strategy parameters
    parameters = Column(JSON, nullable=True)  # Strategy-specific parameters
    risk_parameters = Column(JSON, nullable=True)  # Risk management parameters
    
    # Performance tracking
    total_signals = Column(Integer, default=0)
    successful_signals = Column(Integer, default=0)
    accuracy = Column(Float, default=0.0)
    avg_profit = Column(Float, default=0.0)
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<Strategy(name='{self.name}', type='{self.strategy_type}')>"


class Indicator(Base):
    """
    Indicator model for technical indicator storage
    
    Stores calculated technical indicators for historical analysis
    and backtesting purposes.
    """
    
    __tablename__ = "indicators"
    
    id = Column(Integer, primary_key=True, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timeframe = Column(String(10), nullable=False, index=True)
    indicator_name = Column(String(50), nullable=False, index=True)
    value = Column(Float, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    # Additional context
    parameters = Column(JSON, nullable=True)  # Indicator parameters
    context = Column(JSON, nullable=True)  # Additional context data
    
    def __repr__(self):
        return f"<Indicator(symbol='{self.symbol}', name='{self.indicator_name}', value={self.value})>"


class Model(Base):
    """
    Model model for ML model storage
    
    Stores information about trained machine learning models
    including metadata, performance metrics, and versioning.
    """
    
    __tablename__ = "models"
    
    id = Column(Integer, primary_key=True, index=True)
    model_name = Column(String(100), nullable=False, index=True)
    model_type = Column(String(50), nullable=False)  # 'random_forest', 'neural_network', etc.
    version = Column(String(20), nullable=False)
    
    # Model metadata
    parameters = Column(JSON, nullable=True)  # Model hyperparameters
    features = Column(JSON, nullable=True)  # Feature list
    performance_metrics = Column(JSON, nullable=True)  # Training performance
    
    # File storage
    model_path = Column(String(500), nullable=True)  # Path to model file
    model_size_mb = Column(Float, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<Model(name='{self.model_name}', type='{self.model_type}', version='{self.version}')>"


class DataVersion(Base):
    """
    Data version model for data versioning
    
    Tracks different versions of training data and feature sets
    for model reproducibility and audit trails.
    """
    
    __tablename__ = "data_versions"
    
    id = Column(Integer, primary_key=True, index=True)
    version_name = Column(String(100), unique=True, nullable=False, index=True)
    description = Column(Text, nullable=True)
    
    # Data metadata
    data_source = Column(String(100), nullable=True)
    data_range_start = Column(DateTime, nullable=True)
    data_range_end = Column(DateTime, nullable=True)
    total_records = Column(Integer, nullable=True)
    
    # Feature information
    feature_count = Column(Integer, nullable=True)
    feature_list = Column(JSON, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f"<DataVersion(name='{self.version_name}', records={self.total_records})>"


# Create indexes for performance optimization
Index('idx_signals_symbol_timeframe', Signal.symbol, Signal.timeframe)
Index('idx_signals_timestamp', Signal.timestamp)
Index('idx_logs_timestamp', Log.timestamp)
Index('idx_feedback_signal_id', Feedback.signal_id)
Index('idx_performance_test_run', PerformanceMetrics.test_run_id)
Index('idx_market_regimes_symbol_timeframe', MarketRegime.symbol, MarketRegime.timeframe)
Index('idx_trades_symbol_status', Trade.symbol, Trade.status)
Index('idx_indicators_symbol_name', Indicator.symbol, Indicator.indicator_name)
Index('idx_models_name_type', Model.model_name, Model.model_type)

# Create unique constraints
UniqueConstraint('signal_id', name='uq_signal_id')
UniqueConstraint('name', name='uq_strategy_name')
UniqueConstraint('model_name', 'version', name='uq_model_name_version')
UniqueConstraint('version_name', name='uq_data_version_name')


class MLPrediction(Base):
    """
    ML Prediction model for storing machine learning model predictions
    
    Stores predictions from various ML models (ensemble, student, ONNX) with
    performance metrics and feature information for analysis and optimization.
    """
    
    __tablename__ = "ml_predictions"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    model_name = Column(String(100), nullable=False, index=True)
    model_type = Column(String(50), nullable=False)  # 'ensemble', 'student', 'onnx'
    prediction = Column(Float, nullable=False)
    confidence = Column(Float, nullable=True)
    features_used = Column(JSON, nullable=True)
    inference_latency_ms = Column(Float, nullable=True)
    cache_hit = Column(Boolean, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationships
    signals = relationship("MLSignal", back_populates="prediction")
    
    def __repr__(self):
        return f"<MLPrediction(symbol='{self.symbol}', model='{self.model_name}', prediction={self.prediction})>"


class MLSignal(Base):
    """
    ML Signal model for storing trading signals generated by ML models
    
    Stores trading signals with confidence scores, risk metrics, and
    market conditions for comprehensive signal analysis and backtesting.
    """
    
    __tablename__ = "ml_signals"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    signal_type = Column(String(20), nullable=False, index=True)  # 'buy', 'sell', 'hold'
    signal_strength = Column(Float, nullable=False)
    model_name = Column(String(100), nullable=False, index=True)
    prediction_id = Column(Integer, ForeignKey("ml_predictions.id"), nullable=True)
    confidence = Column(Float, nullable=True)
    risk_score = Column(Float, nullable=True)
    market_conditions = Column(JSON, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationships
    prediction = relationship("MLPrediction", back_populates="signals")
    
    def __repr__(self):
        return f"<MLSignal(symbol='{self.symbol}', type='{self.signal_type}', strength={self.signal_strength})>"


class MLModelPerformance(Base):
    """
    ML Model Performance model for tracking model performance metrics
    
    Stores performance metrics for ML models including accuracy, latency,
    and other key performance indicators for model optimization and selection.
    """
    
    __tablename__ = "ml_model_performance"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    model_name = Column(String(100), nullable=False, index=True)
    model_type = Column(String(50), nullable=False, index=True)
    metric_name = Column(String(50), nullable=False, index=True)  # 'accuracy', 'latency_p50', 'latency_p99', etc.
    metric_value = Column(Float, nullable=False)
    sample_count = Column(Integer, nullable=True)
    time_window_minutes = Column(Integer, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    def __repr__(self):
        return f"<MLModelPerformance(model='{self.model_name}', metric='{self.metric_name}', value={self.metric_value})>"


def create_tables():
    """Create all database tables"""
    Base.metadata.create_all(bind=engine)


def get_session():
    """Get database session"""
    return SessionLocal()


# Example usage and documentation
def example_usage():
    """
    Example usage of the database models
    
    This function demonstrates how to use the database models
    for common operations like creating signals, storing logs,
    and tracking performance metrics.
    """
    
    # Create a new signal
    signal = Signal(
        signal_id="BTC_USDT_15m_rsi_div_20250815_143022",
        symbol="BTC/USDT",
        timeframe="15m",
        direction="long",
        confidence=0.85,
        entry_price=45000.0,
        tp1=45900.0,
        tp2=46800.0,
        tp3=47700.0,
        tp4=48600.0,
        stop_loss=44100.0,
        risk_reward_ratio=2.5,
        pattern_type="rsi_divergence",
        volume_confirmation=True,
        trend_alignment=True,
        market_regime="strong_trend_bull",
        indicators={
            "rsi": 35.2,
            "macd": 0.85,
            "bollinger_position": 0.15,
            "volume_ratio": 1.8,
            "atr": 1200.0
        },
        validation_metrics={
            "volume_ratio": 1.8,
            "trend_strength": 0.75,
            "volatility": 1200.0,
            "momentum": 35.2,
            "breakout_strength": 0.85
        }
    )
    
    # Create a log entry
    log = Log(
        signal_id=signal.signal_id,
        pattern_type="rsi_divergence",
        confidence_score=0.85,
        volume_context={
            "volume_sma": 1500000,
            "current_volume": 2700000,
            "volume_ratio": 1.8
        },
        trend_context={
            "ema_20": 44800,
            "ema_50": 44500,
            "trend_direction": "bullish",
            "trend_strength": 0.75
        }
    )
    
    # Create performance metrics
    perf_metrics = PerformanceMetrics(
        test_run_id="test_run_20250815_143022",
        latency_avg_ms=45.2,
        latency_max_ms=78.5,
        throughput_signals_sec=22.1,
        accuracy=0.82,
        filter_rate=0.65
    )
    
    return signal, log, perf_metrics


if __name__ == "__main__":
    # Create tables when run directly
    create_tables()
    print("Database tables created successfully!")
    
    # Show example usage
    signal, log, perf_metrics = example_usage()
    print(f"Example signal: {signal}")
    print(f"Example log: {log}")
    print(f"Example performance metrics: {perf_metrics}")
